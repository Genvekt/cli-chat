// Code generated by http://github.com/gojuno/minimock (v3.3.10). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HasherMock implements utils.Hasher
type HasherMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPasswordHash          func(ctx context.Context, password string, hash string) (b1 bool)
	inspectFuncCheckPasswordHash   func(ctx context.Context, password string, hash string)
	afterCheckPasswordHashCounter  uint64
	beforeCheckPasswordHashCounter uint64
	CheckPasswordHashMock          mHasherMockCheckPasswordHash

	funcHashPassword          func(ctx context.Context, password string) (s1 string, err error)
	inspectFuncHashPassword   func(ctx context.Context, password string)
	afterHashPasswordCounter  uint64
	beforeHashPasswordCounter uint64
	HashPasswordMock          mHasherMockHashPassword
}

// NewHasherMock returns a mock for utils.Hasher
func NewHasherMock(t minimock.Tester) *HasherMock {
	m := &HasherMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPasswordHashMock = mHasherMockCheckPasswordHash{mock: m}
	m.CheckPasswordHashMock.callArgs = []*HasherMockCheckPasswordHashParams{}

	m.HashPasswordMock = mHasherMockHashPassword{mock: m}
	m.HashPasswordMock.callArgs = []*HasherMockHashPasswordParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHasherMockCheckPasswordHash struct {
	optional           bool
	mock               *HasherMock
	defaultExpectation *HasherMockCheckPasswordHashExpectation
	expectations       []*HasherMockCheckPasswordHashExpectation

	callArgs []*HasherMockCheckPasswordHashParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// HasherMockCheckPasswordHashExpectation specifies expectation struct of the Hasher.CheckPasswordHash
type HasherMockCheckPasswordHashExpectation struct {
	mock      *HasherMock
	params    *HasherMockCheckPasswordHashParams
	paramPtrs *HasherMockCheckPasswordHashParamPtrs
	results   *HasherMockCheckPasswordHashResults
	Counter   uint64
}

// HasherMockCheckPasswordHashParams contains parameters of the Hasher.CheckPasswordHash
type HasherMockCheckPasswordHashParams struct {
	ctx      context.Context
	password string
	hash     string
}

// HasherMockCheckPasswordHashParamPtrs contains pointers to parameters of the Hasher.CheckPasswordHash
type HasherMockCheckPasswordHashParamPtrs struct {
	ctx      *context.Context
	password *string
	hash     *string
}

// HasherMockCheckPasswordHashResults contains results of the Hasher.CheckPasswordHash
type HasherMockCheckPasswordHashResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Optional() *mHasherMockCheckPasswordHash {
	mmCheckPasswordHash.optional = true
	return mmCheckPasswordHash
}

// Expect sets up expected params for Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Expect(ctx context.Context, password string, hash string) *mHasherMockCheckPasswordHash {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	if mmCheckPasswordHash.defaultExpectation == nil {
		mmCheckPasswordHash.defaultExpectation = &HasherMockCheckPasswordHashExpectation{}
	}

	if mmCheckPasswordHash.defaultExpectation.paramPtrs != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by ExpectParams functions")
	}

	mmCheckPasswordHash.defaultExpectation.params = &HasherMockCheckPasswordHashParams{ctx, password, hash}
	for _, e := range mmCheckPasswordHash.expectations {
		if minimock.Equal(e.params, mmCheckPasswordHash.defaultExpectation.params) {
			mmCheckPasswordHash.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPasswordHash.defaultExpectation.params)
		}
	}

	return mmCheckPasswordHash
}

// ExpectCtxParam1 sets up expected param ctx for Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) ExpectCtxParam1(ctx context.Context) *mHasherMockCheckPasswordHash {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	if mmCheckPasswordHash.defaultExpectation == nil {
		mmCheckPasswordHash.defaultExpectation = &HasherMockCheckPasswordHashExpectation{}
	}

	if mmCheckPasswordHash.defaultExpectation.params != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Expect")
	}

	if mmCheckPasswordHash.defaultExpectation.paramPtrs == nil {
		mmCheckPasswordHash.defaultExpectation.paramPtrs = &HasherMockCheckPasswordHashParamPtrs{}
	}
	mmCheckPasswordHash.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckPasswordHash
}

// ExpectPasswordParam2 sets up expected param password for Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) ExpectPasswordParam2(password string) *mHasherMockCheckPasswordHash {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	if mmCheckPasswordHash.defaultExpectation == nil {
		mmCheckPasswordHash.defaultExpectation = &HasherMockCheckPasswordHashExpectation{}
	}

	if mmCheckPasswordHash.defaultExpectation.params != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Expect")
	}

	if mmCheckPasswordHash.defaultExpectation.paramPtrs == nil {
		mmCheckPasswordHash.defaultExpectation.paramPtrs = &HasherMockCheckPasswordHashParamPtrs{}
	}
	mmCheckPasswordHash.defaultExpectation.paramPtrs.password = &password

	return mmCheckPasswordHash
}

// ExpectHashParam3 sets up expected param hash for Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) ExpectHashParam3(hash string) *mHasherMockCheckPasswordHash {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	if mmCheckPasswordHash.defaultExpectation == nil {
		mmCheckPasswordHash.defaultExpectation = &HasherMockCheckPasswordHashExpectation{}
	}

	if mmCheckPasswordHash.defaultExpectation.params != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Expect")
	}

	if mmCheckPasswordHash.defaultExpectation.paramPtrs == nil {
		mmCheckPasswordHash.defaultExpectation.paramPtrs = &HasherMockCheckPasswordHashParamPtrs{}
	}
	mmCheckPasswordHash.defaultExpectation.paramPtrs.hash = &hash

	return mmCheckPasswordHash
}

// Inspect accepts an inspector function that has same arguments as the Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Inspect(f func(ctx context.Context, password string, hash string)) *mHasherMockCheckPasswordHash {
	if mmCheckPasswordHash.mock.inspectFuncCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("Inspect function is already set for HasherMock.CheckPasswordHash")
	}

	mmCheckPasswordHash.mock.inspectFuncCheckPasswordHash = f

	return mmCheckPasswordHash
}

// Return sets up results that will be returned by Hasher.CheckPasswordHash
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Return(b1 bool) *HasherMock {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	if mmCheckPasswordHash.defaultExpectation == nil {
		mmCheckPasswordHash.defaultExpectation = &HasherMockCheckPasswordHashExpectation{mock: mmCheckPasswordHash.mock}
	}
	mmCheckPasswordHash.defaultExpectation.results = &HasherMockCheckPasswordHashResults{b1}
	return mmCheckPasswordHash.mock
}

// Set uses given function f to mock the Hasher.CheckPasswordHash method
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Set(f func(ctx context.Context, password string, hash string) (b1 bool)) *HasherMock {
	if mmCheckPasswordHash.defaultExpectation != nil {
		mmCheckPasswordHash.mock.t.Fatalf("Default expectation is already set for the Hasher.CheckPasswordHash method")
	}

	if len(mmCheckPasswordHash.expectations) > 0 {
		mmCheckPasswordHash.mock.t.Fatalf("Some expectations are already set for the Hasher.CheckPasswordHash method")
	}

	mmCheckPasswordHash.mock.funcCheckPasswordHash = f
	return mmCheckPasswordHash.mock
}

// When sets expectation for the Hasher.CheckPasswordHash which will trigger the result defined by the following
// Then helper
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) When(ctx context.Context, password string, hash string) *HasherMockCheckPasswordHashExpectation {
	if mmCheckPasswordHash.mock.funcCheckPasswordHash != nil {
		mmCheckPasswordHash.mock.t.Fatalf("HasherMock.CheckPasswordHash mock is already set by Set")
	}

	expectation := &HasherMockCheckPasswordHashExpectation{
		mock:   mmCheckPasswordHash.mock,
		params: &HasherMockCheckPasswordHashParams{ctx, password, hash},
	}
	mmCheckPasswordHash.expectations = append(mmCheckPasswordHash.expectations, expectation)
	return expectation
}

// Then sets up Hasher.CheckPasswordHash return parameters for the expectation previously defined by the When method
func (e *HasherMockCheckPasswordHashExpectation) Then(b1 bool) *HasherMock {
	e.results = &HasherMockCheckPasswordHashResults{b1}
	return e.mock
}

// Times sets number of times Hasher.CheckPasswordHash should be invoked
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Times(n uint64) *mHasherMockCheckPasswordHash {
	if n == 0 {
		mmCheckPasswordHash.mock.t.Fatalf("Times of HasherMock.CheckPasswordHash mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPasswordHash.expectedInvocations, n)
	return mmCheckPasswordHash
}

func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) invocationsDone() bool {
	if len(mmCheckPasswordHash.expectations) == 0 && mmCheckPasswordHash.defaultExpectation == nil && mmCheckPasswordHash.mock.funcCheckPasswordHash == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPasswordHash.mock.afterCheckPasswordHashCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPasswordHash.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPasswordHash implements utils.Hasher
func (mmCheckPasswordHash *HasherMock) CheckPasswordHash(ctx context.Context, password string, hash string) (b1 bool) {
	mm_atomic.AddUint64(&mmCheckPasswordHash.beforeCheckPasswordHashCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPasswordHash.afterCheckPasswordHashCounter, 1)

	if mmCheckPasswordHash.inspectFuncCheckPasswordHash != nil {
		mmCheckPasswordHash.inspectFuncCheckPasswordHash(ctx, password, hash)
	}

	mm_params := HasherMockCheckPasswordHashParams{ctx, password, hash}

	// Record call args
	mmCheckPasswordHash.CheckPasswordHashMock.mutex.Lock()
	mmCheckPasswordHash.CheckPasswordHashMock.callArgs = append(mmCheckPasswordHash.CheckPasswordHashMock.callArgs, &mm_params)
	mmCheckPasswordHash.CheckPasswordHashMock.mutex.Unlock()

	for _, e := range mmCheckPasswordHash.CheckPasswordHashMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCheckPasswordHash.CheckPasswordHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPasswordHash.CheckPasswordHashMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPasswordHash.CheckPasswordHashMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPasswordHash.CheckPasswordHashMock.defaultExpectation.paramPtrs

		mm_got := HasherMockCheckPasswordHashParams{ctx, password, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPasswordHash.t.Errorf("HasherMock.CheckPasswordHash got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmCheckPasswordHash.t.Errorf("HasherMock.CheckPasswordHash got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmCheckPasswordHash.t.Errorf("HasherMock.CheckPasswordHash got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPasswordHash.t.Errorf("HasherMock.CheckPasswordHash got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPasswordHash.CheckPasswordHashMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPasswordHash.t.Fatal("No results are set for the HasherMock.CheckPasswordHash")
		}
		return (*mm_results).b1
	}
	if mmCheckPasswordHash.funcCheckPasswordHash != nil {
		return mmCheckPasswordHash.funcCheckPasswordHash(ctx, password, hash)
	}
	mmCheckPasswordHash.t.Fatalf("Unexpected call to HasherMock.CheckPasswordHash. %v %v %v", ctx, password, hash)
	return
}

// CheckPasswordHashAfterCounter returns a count of finished HasherMock.CheckPasswordHash invocations
func (mmCheckPasswordHash *HasherMock) CheckPasswordHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPasswordHash.afterCheckPasswordHashCounter)
}

// CheckPasswordHashBeforeCounter returns a count of HasherMock.CheckPasswordHash invocations
func (mmCheckPasswordHash *HasherMock) CheckPasswordHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPasswordHash.beforeCheckPasswordHashCounter)
}

// Calls returns a list of arguments used in each call to HasherMock.CheckPasswordHash.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPasswordHash *mHasherMockCheckPasswordHash) Calls() []*HasherMockCheckPasswordHashParams {
	mmCheckPasswordHash.mutex.RLock()

	argCopy := make([]*HasherMockCheckPasswordHashParams, len(mmCheckPasswordHash.callArgs))
	copy(argCopy, mmCheckPasswordHash.callArgs)

	mmCheckPasswordHash.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPasswordHashDone returns true if the count of the CheckPasswordHash invocations corresponds
// the number of defined expectations
func (m *HasherMock) MinimockCheckPasswordHashDone() bool {
	if m.CheckPasswordHashMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPasswordHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPasswordHashMock.invocationsDone()
}

// MinimockCheckPasswordHashInspect logs each unmet expectation
func (m *HasherMock) MinimockCheckPasswordHashInspect() {
	for _, e := range m.CheckPasswordHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HasherMock.CheckPasswordHash with params: %#v", *e.params)
		}
	}

	afterCheckPasswordHashCounter := mm_atomic.LoadUint64(&m.afterCheckPasswordHashCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPasswordHashMock.defaultExpectation != nil && afterCheckPasswordHashCounter < 1 {
		if m.CheckPasswordHashMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HasherMock.CheckPasswordHash")
		} else {
			m.t.Errorf("Expected call to HasherMock.CheckPasswordHash with params: %#v", *m.CheckPasswordHashMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPasswordHash != nil && afterCheckPasswordHashCounter < 1 {
		m.t.Error("Expected call to HasherMock.CheckPasswordHash")
	}

	if !m.CheckPasswordHashMock.invocationsDone() && afterCheckPasswordHashCounter > 0 {
		m.t.Errorf("Expected %d calls to HasherMock.CheckPasswordHash but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPasswordHashMock.expectedInvocations), afterCheckPasswordHashCounter)
	}
}

type mHasherMockHashPassword struct {
	optional           bool
	mock               *HasherMock
	defaultExpectation *HasherMockHashPasswordExpectation
	expectations       []*HasherMockHashPasswordExpectation

	callArgs []*HasherMockHashPasswordParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// HasherMockHashPasswordExpectation specifies expectation struct of the Hasher.HashPassword
type HasherMockHashPasswordExpectation struct {
	mock      *HasherMock
	params    *HasherMockHashPasswordParams
	paramPtrs *HasherMockHashPasswordParamPtrs
	results   *HasherMockHashPasswordResults
	Counter   uint64
}

// HasherMockHashPasswordParams contains parameters of the Hasher.HashPassword
type HasherMockHashPasswordParams struct {
	ctx      context.Context
	password string
}

// HasherMockHashPasswordParamPtrs contains pointers to parameters of the Hasher.HashPassword
type HasherMockHashPasswordParamPtrs struct {
	ctx      *context.Context
	password *string
}

// HasherMockHashPasswordResults contains results of the Hasher.HashPassword
type HasherMockHashPasswordResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashPassword *mHasherMockHashPassword) Optional() *mHasherMockHashPassword {
	mmHashPassword.optional = true
	return mmHashPassword
}

// Expect sets up expected params for Hasher.HashPassword
func (mmHashPassword *mHasherMockHashPassword) Expect(ctx context.Context, password string) *mHasherMockHashPassword {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &HasherMockHashPasswordExpectation{}
	}

	if mmHashPassword.defaultExpectation.paramPtrs != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by ExpectParams functions")
	}

	mmHashPassword.defaultExpectation.params = &HasherMockHashPasswordParams{ctx, password}
	for _, e := range mmHashPassword.expectations {
		if minimock.Equal(e.params, mmHashPassword.defaultExpectation.params) {
			mmHashPassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashPassword.defaultExpectation.params)
		}
	}

	return mmHashPassword
}

// ExpectCtxParam1 sets up expected param ctx for Hasher.HashPassword
func (mmHashPassword *mHasherMockHashPassword) ExpectCtxParam1(ctx context.Context) *mHasherMockHashPassword {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &HasherMockHashPasswordExpectation{}
	}

	if mmHashPassword.defaultExpectation.params != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Expect")
	}

	if mmHashPassword.defaultExpectation.paramPtrs == nil {
		mmHashPassword.defaultExpectation.paramPtrs = &HasherMockHashPasswordParamPtrs{}
	}
	mmHashPassword.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHashPassword
}

// ExpectPasswordParam2 sets up expected param password for Hasher.HashPassword
func (mmHashPassword *mHasherMockHashPassword) ExpectPasswordParam2(password string) *mHasherMockHashPassword {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &HasherMockHashPasswordExpectation{}
	}

	if mmHashPassword.defaultExpectation.params != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Expect")
	}

	if mmHashPassword.defaultExpectation.paramPtrs == nil {
		mmHashPassword.defaultExpectation.paramPtrs = &HasherMockHashPasswordParamPtrs{}
	}
	mmHashPassword.defaultExpectation.paramPtrs.password = &password

	return mmHashPassword
}

// Inspect accepts an inspector function that has same arguments as the Hasher.HashPassword
func (mmHashPassword *mHasherMockHashPassword) Inspect(f func(ctx context.Context, password string)) *mHasherMockHashPassword {
	if mmHashPassword.mock.inspectFuncHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("Inspect function is already set for HasherMock.HashPassword")
	}

	mmHashPassword.mock.inspectFuncHashPassword = f

	return mmHashPassword
}

// Return sets up results that will be returned by Hasher.HashPassword
func (mmHashPassword *mHasherMockHashPassword) Return(s1 string, err error) *HasherMock {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Set")
	}

	if mmHashPassword.defaultExpectation == nil {
		mmHashPassword.defaultExpectation = &HasherMockHashPasswordExpectation{mock: mmHashPassword.mock}
	}
	mmHashPassword.defaultExpectation.results = &HasherMockHashPasswordResults{s1, err}
	return mmHashPassword.mock
}

// Set uses given function f to mock the Hasher.HashPassword method
func (mmHashPassword *mHasherMockHashPassword) Set(f func(ctx context.Context, password string) (s1 string, err error)) *HasherMock {
	if mmHashPassword.defaultExpectation != nil {
		mmHashPassword.mock.t.Fatalf("Default expectation is already set for the Hasher.HashPassword method")
	}

	if len(mmHashPassword.expectations) > 0 {
		mmHashPassword.mock.t.Fatalf("Some expectations are already set for the Hasher.HashPassword method")
	}

	mmHashPassword.mock.funcHashPassword = f
	return mmHashPassword.mock
}

// When sets expectation for the Hasher.HashPassword which will trigger the result defined by the following
// Then helper
func (mmHashPassword *mHasherMockHashPassword) When(ctx context.Context, password string) *HasherMockHashPasswordExpectation {
	if mmHashPassword.mock.funcHashPassword != nil {
		mmHashPassword.mock.t.Fatalf("HasherMock.HashPassword mock is already set by Set")
	}

	expectation := &HasherMockHashPasswordExpectation{
		mock:   mmHashPassword.mock,
		params: &HasherMockHashPasswordParams{ctx, password},
	}
	mmHashPassword.expectations = append(mmHashPassword.expectations, expectation)
	return expectation
}

// Then sets up Hasher.HashPassword return parameters for the expectation previously defined by the When method
func (e *HasherMockHashPasswordExpectation) Then(s1 string, err error) *HasherMock {
	e.results = &HasherMockHashPasswordResults{s1, err}
	return e.mock
}

// Times sets number of times Hasher.HashPassword should be invoked
func (mmHashPassword *mHasherMockHashPassword) Times(n uint64) *mHasherMockHashPassword {
	if n == 0 {
		mmHashPassword.mock.t.Fatalf("Times of HasherMock.HashPassword mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashPassword.expectedInvocations, n)
	return mmHashPassword
}

func (mmHashPassword *mHasherMockHashPassword) invocationsDone() bool {
	if len(mmHashPassword.expectations) == 0 && mmHashPassword.defaultExpectation == nil && mmHashPassword.mock.funcHashPassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashPassword.mock.afterHashPasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashPassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashPassword implements utils.Hasher
func (mmHashPassword *HasherMock) HashPassword(ctx context.Context, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHashPassword.beforeHashPasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmHashPassword.afterHashPasswordCounter, 1)

	if mmHashPassword.inspectFuncHashPassword != nil {
		mmHashPassword.inspectFuncHashPassword(ctx, password)
	}

	mm_params := HasherMockHashPasswordParams{ctx, password}

	// Record call args
	mmHashPassword.HashPasswordMock.mutex.Lock()
	mmHashPassword.HashPasswordMock.callArgs = append(mmHashPassword.HashPasswordMock.callArgs, &mm_params)
	mmHashPassword.HashPasswordMock.mutex.Unlock()

	for _, e := range mmHashPassword.HashPasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHashPassword.HashPasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashPassword.HashPasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmHashPassword.HashPasswordMock.defaultExpectation.params
		mm_want_ptrs := mmHashPassword.HashPasswordMock.defaultExpectation.paramPtrs

		mm_got := HasherMockHashPasswordParams{ctx, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHashPassword.t.Errorf("HasherMock.HashPassword got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmHashPassword.t.Errorf("HasherMock.HashPassword got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashPassword.t.Errorf("HasherMock.HashPassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashPassword.HashPasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmHashPassword.t.Fatal("No results are set for the HasherMock.HashPassword")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHashPassword.funcHashPassword != nil {
		return mmHashPassword.funcHashPassword(ctx, password)
	}
	mmHashPassword.t.Fatalf("Unexpected call to HasherMock.HashPassword. %v %v", ctx, password)
	return
}

// HashPasswordAfterCounter returns a count of finished HasherMock.HashPassword invocations
func (mmHashPassword *HasherMock) HashPasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashPassword.afterHashPasswordCounter)
}

// HashPasswordBeforeCounter returns a count of HasherMock.HashPassword invocations
func (mmHashPassword *HasherMock) HashPasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashPassword.beforeHashPasswordCounter)
}

// Calls returns a list of arguments used in each call to HasherMock.HashPassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashPassword *mHasherMockHashPassword) Calls() []*HasherMockHashPasswordParams {
	mmHashPassword.mutex.RLock()

	argCopy := make([]*HasherMockHashPasswordParams, len(mmHashPassword.callArgs))
	copy(argCopy, mmHashPassword.callArgs)

	mmHashPassword.mutex.RUnlock()

	return argCopy
}

// MinimockHashPasswordDone returns true if the count of the HashPassword invocations corresponds
// the number of defined expectations
func (m *HasherMock) MinimockHashPasswordDone() bool {
	if m.HashPasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashPasswordMock.invocationsDone()
}

// MinimockHashPasswordInspect logs each unmet expectation
func (m *HasherMock) MinimockHashPasswordInspect() {
	for _, e := range m.HashPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HasherMock.HashPassword with params: %#v", *e.params)
		}
	}

	afterHashPasswordCounter := mm_atomic.LoadUint64(&m.afterHashPasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashPasswordMock.defaultExpectation != nil && afterHashPasswordCounter < 1 {
		if m.HashPasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HasherMock.HashPassword")
		} else {
			m.t.Errorf("Expected call to HasherMock.HashPassword with params: %#v", *m.HashPasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashPassword != nil && afterHashPasswordCounter < 1 {
		m.t.Error("Expected call to HasherMock.HashPassword")
	}

	if !m.HashPasswordMock.invocationsDone() && afterHashPasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to HasherMock.HashPassword but found %d calls",
			mm_atomic.LoadUint64(&m.HashPasswordMock.expectedInvocations), afterHashPasswordCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HasherMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPasswordHashInspect()

			m.MinimockHashPasswordInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HasherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HasherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPasswordHashDone() &&
		m.MinimockHashPasswordDone()
}
